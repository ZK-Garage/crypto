// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) DUSK NETWORK. All rights reserved.

//! Key module contains the utilities and data structures
//! that support the generation and usage of Commit and
//! Opening keys.
use super::proof::KZGProof;
use crate::transcript::TranscriptWrapper;
use crate::{error::Error, transcript::TranscriptProtocol, util};
use ark_ec::{
    msm::VariableBaseMSM, AffineCurve, PairingEngine, ProjectiveCurve,
};
use ark_ff::PrimeField;
use ark_poly::{
    polynomial::univariate::DensePolynomial, Polynomial, UVPolynomial,
};
use ark_poly_commit::kzg10::Commitment;
use num_traits::{One, Zero};

/// CommitKey is used to commit to a polynomial which is bounded by the
/// max_degree.
#[derive(Debug, Clone, PartialEq)]
pub struct CommitKey<E: PairingEngine> {
    /// Group elements of the form `{ \beta^i G }`, where `i` ranges from 0 to
    /// `degree`.
    pub(crate) powers_of_g: Vec<E::G1Affine>,
}

impl<E: PairingEngine> CommitKey<E> {
    /*
    /// Serialize the [`CommitKey`] into bytes.
    ///
    /// This operation is designed to store the raw representation of the
    /// contents of the CommitKey. Therefore, the size of the bytes outputed
    /// by this function is expected to be the double than the one that
    /// `CommitKey::to_bytes`.
    ///
    /// # Note
    /// This function should be used when we want to serialize the CommitKey
    /// allowing a really fast deserialization later.
    /// This functions output should not be used by the regular
    /// `CommitKey::from_bytes` fn.
    pub fn to_raw_var_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::with_capacity(
            u64::SIZE + self.powers_of_g.len() * E::G1Affine::RAW_SIZE,
        );

        let len = self.powers_of_g.len() as u64;
        let len = len.to_le_bytes();
        bytes.extend_from_slice(&len);

        self.powers_of_g
            .iter()
            .for_each(|g| bytes.extend_from_slice(&g.to_raw_bytes()));

        bytes
    }

    /// Deserialize [`CommitKey`] from a set of bytes created by
    /// [`CommitKey::to_raw_var_bytes`].
    ///
    /// The bytes source is expected to be trusted and no check will be
    /// performed reggarding the points security
    ///
    /// # Safety
    /// This function will not produce any memory errors but can deal to the
    /// generation of invalid or unsafe points/keys. To make sure this does not
    /// happen, the inputed bytes must match the ones that were generated by
    /// the encoding functions of this lib.
    pub unsafe fn from_slice_unchecked(bytes: &[u8]) -> Self {
        let mut len = [0u8; u64::SIZE];
        len.copy_from_slice(&bytes[..u64::SIZE]);
        let len = u64::from_le_bytes(len);

        let powers_of_g = bytes[u64::SIZE..]
            .chunks_exact(E::G1Affine::RAW_SIZE)
            .zip(0..len)
            .map(|(c, _)| E::G1Affine::from_slice_unchecked(c))
            .collect();

        Self { powers_of_g }
    }

    /// Serialises the [`CommitKey`] into a byte slice.
    pub fn to_var_bytes(&self) -> Vec<u8> {
        self.powers_of_g
            .iter()
            .flat_map(|item| item.to_bytes().to_vec())
            .collect()
    }

    /// Deserialise a slice of bytes into a [`CommitKey`] struct performing
    /// security and consistency checks for each point that the bytes
    /// contain.
    ///
    /// # Note
    /// This function can be really slow if the [`CommitKey`] has a certain
    /// degree/size. If the bytes come from a trusted source such as a local
    /// file, we recommend to use [`CommitKey::from_slice_unchecked`] and
    /// [`CommitKey::to_raw_var_bytes`].
    pub fn from_slice(bytes: &[u8]) -> Result<CommitKey<E>, Error> {
        let powers_of_g = bytes
            .chunks(E::G1Affine::SIZE)
            .map(|chunk| E::G1Affine::from_slice(chunk))
            .collect::<Result<Vec<E::G1Affine>, dusk_bytes::Error>>()?;

        Ok(CommitKey { powers_of_g })
    }
    */

    /// Returns the maximum degree polynomial that you can commit to.
    pub(crate) fn max_degree(&self) -> usize {
        self.powers_of_g.len() - 1
    }

    /// Truncates the commit key to a lower max degree.
    /// Returns an error if the truncated degree is zero or if the truncated
    /// degree is larger than the max degree of the commit key.
    pub(crate) fn truncate(
        &self,
        mut truncated_degree: usize,
    ) -> Result<CommitKey<E>, Error> {
        match truncated_degree {
            // Check that the truncated degree is not zero
            0 => Err(Error::TruncatedDegreeIsZero),
            // Check that max degree is less than truncated degree
            i if i > self.max_degree() => Err(Error::TruncatedDegreeTooLarge),
            i => {
                if i == 1 {
                    truncated_degree += 1
                };
                let truncated_powers = Self {
                    powers_of_g: self.powers_of_g[..=truncated_degree].to_vec(),
                };
                Ok(truncated_powers)
            }
        }
    }

    /// Checks whether the polynomial we are committing to:
    /// - Has zero degree
    /// - Has a degree which is more than the max supported degree
    ///
    /// Returns an error if any of the above conditions are true.
    fn check_commit_degree_is_within_bounds(
        &self,
        poly_degree: usize,
    ) -> Result<(), Error> {
        match (poly_degree == 0, poly_degree > self.max_degree()) {
            (true, _) => Err(Error::PolynomialDegreeIsZero),
            (false, true) => Err(Error::PolynomialDegreeTooLarge),
            (false, false) => Ok(()),
        }
    }

    /// Commits to a [`Polynomial`] returning the corresponding [`Commitment`].
    ///
    /// Returns an error if the polynomial's degree is more than the max degree
    /// of the commit key.
    pub(crate) fn commit(
        &self,
        polynomial: DensePolynomial<E::Fr>,
    ) -> Result<Commitment<E>, Error> {
        // Check whether we can safely commit to this polynomial
        self.check_commit_degree_is_within_bounds(polynomial.degree())?;

        // Compute commitment
        let com_point: E::G1Projective = VariableBaseMSM::multi_scalar_mul(
            &self.powers_of_g,
            polynomial
                .coeffs()
                .iter()
                .map(|s| s.into_repr())
                .collect::<Vec<<E::Fr as PrimeField>::BigInt>>()
                .as_slice(),
        );

        Ok(Commitment(com_point.into()))
    }

    /// Computes a single witness for multiple polynomials at the same point, by
    /// taking a random linear combination of the individual witnesses.
    /// We apply the same optimisation mentioned in when computing each witness;
    /// removing f(z).
    pub(crate) fn compute_aggregate_witness(
        &self,
        polynomials: &[DensePolynomial<E::Fr>],
        point: &E::Fr,
        transcript: &mut TranscriptWrapper<E>,
    ) -> DensePolynomial<E::Fr> {
        let challenge: E::Fr =
            transcript.challenge_scalar(b"aggregate_witness");
        let powers = util::powers_of(&challenge, polynomials.len() - 1);

        assert_eq!(powers.len(), polynomials.len());

        let numerator_terms: Vec<DensePolynomial<E::Fr>> = polynomials
            .iter()
            .zip(powers.iter())
            .map(|(poly, challenge_power)| poly * *challenge_power)
            .collect();

        let mut numerator = DensePolynomial::zero();
        for term in numerator_terms.iter() {
            numerator += term;
        }
        util::ruffini(numerator, *point)
    }
}

/// Opening Key is used to verify opening proofs made about a committed
/// polynomial.
#[derive(Clone, Debug)]
pub struct OpeningKey<E: PairingEngine> {
    /// The generator of G1.
    pub(crate) g: E::G1Affine,
    /// The generator of G2.
    pub(crate) h: E::G2Affine,
    /// \beta times the above generator of G2.
    pub(crate) beta_h: E::G2Affine,
    /// The generator of G2, prepared for use in pairings.
    pub(crate) prepared_h: E::G2Prepared,
    /// \beta times the above generator of G2, prepared for use in pairings.
    pub(crate) prepared_beta_h: E::G2Prepared,
}

/*
impl<E: PairingEngine>
    Serializable<{ E::G1Affine::SIZE + E::G2Affine::SIZE * 2 }>
    for OpeningKey<E>
{
    // type Error = dusk_bytes::Error;
    #[allow(unused_must_use)]
    fn to_bytes(&self) -> [u8; Self::SIZE] {
        // use dusk_bytes::Write;
        let mut buf = [0u8; Self::SIZE];
        let mut writer = &mut buf[..];
        // This can't fail therefore we don't care about the Result nor use it.
        writer.write(&self.g.to_bytes());
        writer.write(&self.h.to_bytes());
        writer.write(&self.beta_h.to_bytes());

        buf
    }

    fn from_bytes(buf: &[u8; Self::SIZE]) -> Result<Self, Self::Error> {
        let mut buffer = &buf[..];
        let g = E::G1Affine::from_reader(&mut buffer)?;
        let h = E::G2Affine::from_reader(&mut buffer)?;
        let beta_h = E::G2Affine::from_reader(&mut buffer)?;

        Ok(Self::new(g, h, beta_h))
    }
}

*/
impl<E: PairingEngine> OpeningKey<E> {
    pub(crate) fn new(
        g: E::G1Affine,
        h: E::G2Affine,
        beta_h: E::G2Affine,
    ) -> OpeningKey<E> {
        let prepared_h = E::G2Prepared::from(h);
        let prepared_beta_h = E::G2Prepared::from(beta_h);
        OpeningKey {
            g,
            h,
            beta_h,
            prepared_h,
            prepared_beta_h,
        }
    }

    /// Checks whether a batch of polynomials evaluated at different points,
    /// returned their specified value.
    pub(crate) fn batch_check(
        &self,
        points: &[E::Fr],
        proofs: &[KZGProof<E>],
        transcript: &mut TranscriptWrapper<E>,
    ) -> Result<(), Error> {
        let mut total_c = E::G1Projective::zero();
        let mut total_w = E::G1Projective::zero();

        let challenge: E::Fr = transcript.challenge_scalar(b"batch"); // XXX: Verifier can add their own randomness at this point
        let powers = util::powers_of(&challenge, proofs.len() - 1);
        // Instead of multiplying g and gamma_g in each turn, we simply
        // accumulate their coefficients and perform a final
        // multiplication at the end.
        let mut g_multiplier = E::Fr::zero();

        for ((proof, challenge), point) in proofs.iter().zip(powers).zip(points)
        {
            let mut c = E::G1Projective::from(proof.commitment_to_polynomial.0);
            let w = proof.commitment_to_witness.0;
            c += w.mul(point.into_repr());
            g_multiplier += challenge * proof.evaluated_point;

            total_c += c.mul(challenge.into_repr());
            total_w += w.mul(challenge.into_repr());
        }
        total_c -= self.g.mul(g_multiplier.into_repr());

        let affine_total_w = E::G1Affine::from(-total_w);
        let affine_total_c = E::G1Affine::from(total_c);

        let pairing = E::product_of_pairings(&[
            (affine_total_w.into(), self.prepared_beta_h.clone()),
            (affine_total_c.into(), self.prepared_h.clone()),
        ]);

        if pairing != E::Fqk::one() {
            return Err(Error::PairingCheckFailure);
        };
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use std::marker::PhantomData;

    use super::*;
    use crate::commitment_scheme::kzg10::{
        KZGAggregateProof, PublicParameters,
    };
    use ark_bls12_381::{Bls12_381, Fr as BlsScalar, FrParameters};
    use ark_ec::{PairingEngine, TEModelParameters};
    use ark_ff::Fp256;
    use ark_poly::Polynomial;
    use rand::{rngs::StdRng, SeedableRng};

    fn gen_rand() -> StdRng {
        // arbitrary seed
        let seed = [
            1, 0, 0, 0, 23, 0, 0, 0, 200, 1, 0, 0, 210, 30, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        StdRng::from_seed(seed)
    }

    // Checks that a polynomial `p` was evaluated at a point `z` and returned
    // the value specified `v`. ie. v = p(z).
    fn check<E: PairingEngine>(
        op_key: &OpeningKey<E>,
        point: E::Fr,
        proof: KZGProof<E>,
    ) -> bool {
        let inner_a: E::G1Affine =
            (proof.commitment_to_polynomial.0.into_projective()
                + -(op_key.g.mul(proof.evaluated_point.into_repr())))
            .into();

        let inner_b: E::G2Affine = (op_key.beta_h.into_projective()
            + -(op_key.h.mul(point.into_repr())))
        .into();
        let prepared_inner_b = E::G2Prepared::from(-inner_b);

        let pairing = E::product_of_pairings(&[
            (inner_a.into(), op_key.prepared_h.clone()),
            (proof.commitment_to_witness.0.into(), prepared_inner_b),
        ]);

        pairing == E::Fqk::one()
    }

    // Creates an opening proof that a polynomial `p` was correctly evaluated at
    // p(z) and produced the value `v`. ie v = p(z).
    // Returns an error if the polynomials degree is too large.
    fn open_single<E: PairingEngine<Fr = Fp256<FrParameters>>>(
        ck: &CommitKey<E>,
        polynomial: DensePolynomial<E::Fr>,
        value: &E::Fr,
        point: &E::Fr,
    ) -> Result<KZGProof<E>, Error> {
        let witness_poly =
            compute_single_witness::<BlsScalar>(polynomial.clone(), point);
        Ok(KZGProof {
            commitment_to_witness: ck.commit(witness_poly)?,
            evaluated_point: *value,
            commitment_to_polynomial: ck.commit(polynomial)?,
        })
    }

    // Creates an opening proof that multiple polynomials were evaluated at the
    // same point and that each evaluation produced the correct evaluation
    // point. Returns an error if any of the polynomial's degree are too large.
    fn open_multiple<
        E: PairingEngine,
        P: TEModelParameters<BaseField = E::Fr>,
    >(
        ck: &CommitKey<E>,
        polynomials: &[DensePolynomial<E::Fr>],
        evaluations: Vec<E::Fr>,
        point: &E::Fr,
        transcript: &mut TranscriptWrapper<E>,
    ) -> Result<KZGAggregateProof<E, P>, Error> {
        // Commit to polynomials
        let mut polynomial_commitments = Vec::with_capacity(polynomials.len());
        for poly in polynomials.iter() {
            polynomial_commitments.push(ck.commit(poly.clone())?)
        }

        // Compute the aggregate witness for polynomials
        let witness_poly =
            ck.compute_aggregate_witness(polynomials, point, transcript);
        //
        // Commit to witness polynomial
        let witness_commitment = ck.commit(witness_poly)?;
        //
        let aggregate_proof = KZGAggregateProof {
            commitment_to_witness: witness_commitment,
            evaluated_points: evaluations,
            commitments_to_polynomials: polynomial_commitments,
            _marker: PhantomData,
        };
        Ok(aggregate_proof)
    }

    // For a given polynomial `p` and a point `z`, compute the witness
    // for p(z) using Ruffini's method for simplicity.
    // The Witness is the quotient of f(x) - f(z) / x-z.
    // However we note that the quotient polynomial is invariant under the value
    // // f(z) ie. only the remainder changes. We can therefore compute the
    // // witness as f(x) / x - z and only use the remainder term f(z) during
    // // verification.
    fn compute_single_witness<F: PrimeField>(
        polynomial: DensePolynomial<F>,
        point: &F,
    ) -> DensePolynomial<F> {
        // Computes `f(x) / x-z`, returning it as the witness poly
        util::ruffini(polynomial, *point)
    }

    // Creates a proving key and verifier key based on a specified degree
    fn setup_test<E: PairingEngine>(
        degree: usize,
    ) -> Result<(CommitKey<E>, OpeningKey<E>), Error> {
        let srs = PublicParameters::setup(degree, &mut rand::thread_rng())?;
        srs.trim(degree)
    }

    #[test]
    fn test_basic_commit() -> Result<(), Error> {
        let degree = 25;
        let (ck, opening_key) = setup_test::<Bls12_381>(degree)?;
        let point = BlsScalar::from(10u64);

        let poly = DensePolynomial::rand(degree, &mut gen_rand());
        let value = poly.evaluate(&point);

        let proof = open_single(&ck, poly, &value, &point)?;

        let ok = check(&opening_key, point, proof);
        assert!(ok);
        Ok(())
    }
    #[test]
    fn test_batch_verification() -> Result<(), Error> {
        let degree = 25;
        let (ck, vk) = setup_test::<Bls12_381>(degree)?;

        let point_a = BlsScalar::from(10u64);
        let point_b = BlsScalar::from(11u64);

        // Compute secret polynomial a
        let poly_a = DensePolynomial::rand(degree, &mut gen_rand());
        let value_a = poly_a.evaluate(&point_a);
        let proof_a = open_single(&ck, poly_a, &value_a, &point_a)?;
        assert!(check(&vk, point_a, proof_a));

        // Compute secret polynomial b
        let poly_b = DensePolynomial::rand(degree, &mut gen_rand());
        let value_b = poly_b.evaluate(&point_b);
        let proof_b = open_single(&ck, poly_b, &value_b, &point_b)?;
        assert!(check(&vk, point_b, proof_b));

        vk.batch_check(
            &[point_a, point_b],
            &[proof_a, proof_b],
            &mut TranscriptWrapper::new(b""),
        )
    }
    #[test]
    fn test_aggregate_witness() -> Result<(), Error> {
        let max_degree = 27;
        let (ck, opening_key) = setup_test::<Bls12_381>(max_degree)?;
        let point = BlsScalar::from(10u64);

        // Committer's View
        let aggregated_proof: KZGAggregateProof<
            Bls12_381,
            ark_ed_on_bls12_381::EdwardsParameters,
        > = {
            // Compute secret polynomials and their evaluations
            let poly_a = DensePolynomial::rand(25, &mut gen_rand());
            let poly_a_eval = poly_a.evaluate(&point);

            let poly_b = DensePolynomial::rand(26 + 1, &mut gen_rand());
            let poly_b_eval = poly_b.evaluate(&point);

            let poly_c = DensePolynomial::rand(27, &mut gen_rand());
            let poly_c_eval = poly_c.evaluate(&point);

            open_multiple(
                &ck,
                &[poly_a, poly_b, poly_c],
                vec![poly_a_eval, poly_b_eval, poly_c_eval],
                &point,
                &mut TranscriptWrapper::new(b"agg_flatten"),
            )?
        };

        // Verifier's View
        let ok = {
            let flattened_proof = aggregated_proof
                .flatten(&mut TranscriptWrapper::new(b"agg_flatten"));
            check(&opening_key, point, flattened_proof)
        };

        assert!(ok);
        Ok(())
    }

    #[test]
    fn test_batch_with_aggregation() -> Result<(), Error> {
        let max_degree = 28;
        let (ck, opening_key) = setup_test::<Bls12_381>(max_degree)?;
        let point_a = BlsScalar::from(10);
        let point_b = BlsScalar::from(11);

        // Committer's View
        let (aggregated_proof, single_proof) = {
            // Compute secret polynomial and their evaluations
            let poly_a = DensePolynomial::rand(25, &mut gen_rand());
            let poly_a_eval = poly_a.evaluate(&point_a);

            let poly_b = DensePolynomial::rand(26, &mut gen_rand());
            let poly_b_eval = poly_b.evaluate(&point_a);

            let poly_c = DensePolynomial::rand(27, &mut gen_rand());
            let poly_c_eval = poly_c.evaluate(&point_a);

            let poly_d = DensePolynomial::rand(28, &mut gen_rand());
            let poly_d_eval = poly_d.evaluate(&point_b);

            let aggregated_proof: KZGAggregateProof<
                Bls12_381,
                ark_ed_on_bls12_381::EdwardsParameters,
            > = open_multiple(
                &ck,
                &[poly_a, poly_b, poly_c],
                vec![poly_a_eval, poly_b_eval, poly_c_eval],
                &point_a,
                &mut TranscriptWrapper::new(b"agg_batch"),
            )?;

            let single_proof =
                open_single(&ck, poly_d, &poly_d_eval, &point_b)?;

            (aggregated_proof, single_proof)
        };

        // Verifier's View

        let mut transcript = TranscriptWrapper::new(b"agg_batch");
        let flattened_proof = aggregated_proof.flatten(&mut transcript);

        opening_key.batch_check(
            &[point_a, point_b],
            &[flattened_proof, single_proof],
            &mut transcript,
        )
    }

    /*
    #[test]
    fn commit_key_serde() -> Result<(), Error> {
        let (commit_key, _) = setup_test(11)?;
        let ck_bytes = commit_key.to_var_bytes();
        let ck_bytes_safe = CommitKey::from_slice(&ck_bytes)?;

        assert_eq!(commit_key.powers_of_g, ck_bytes_safe.powers_of_g);
        Ok(())
    }

    #[test]
    fn opening_key_dusk_bytes() -> Result<(), Error> {
        let (_, opening_key) = setup_test(7)?;
        let ok_bytes = opening_key.to_bytes();
        let obtained_key = OpeningKey::from_bytes(&ok_bytes)?;

        assert_eq!(opening_key.to_bytes(), obtained_key.to_bytes());
        Ok(())
    }

    #[test]
    fn commit_key_bytes_unchecked() -> Result<(), Error> {
        let (ck, _) = setup_test(7)?;

        let ck_p = unsafe {
            let bytes = ck.to_raw_var_bytes();
            CommitKey::from_slice_unchecked(&bytes)
        };

        assert_eq!(ck, ck_p);
        Ok(())
    }
    */
}
